/*You need to import the PApplet class  so the Bird class has access to Processing  function calls-really PApplet method calls*/import processing.core.PApplet;public class Bird{  /* properties   Properties are usually declared private in java,   using the "private" modifer. Public accessor    and mutator (getter/setter) methods are then   created for each private property, which are     used to access/change the properties. I've just    added one set below: getOffsetX() and setOffsetX()    as an example*/  private PApplet p;  private float offsetX, offsetY, offsetZ;  private float w, h;  private int bodyFill;  private int wingFill;  private float ang = 0, ang2 = 0, ang3 = 0, ang4 = 0;  private float radiusX = 120, radiusY = 200, radiusZ = 700;  private float rotX = 15, rotY = 10, rotZ = 5;  private float flapSpeed = .4f;  private float rotSpeed = .1f;  // constructors  public Bird(PApplet p){    this(p, 0, 0, 0, 60, 80);  }  public Bird(PApplet p, float offsetX, float offsetY, float offsetZ,               float w, float h){    this.p=p;    this.offsetX = offsetX;    this.offsetY = offsetY;    this.offsetZ = offsetZ;    this.h=h;    this.w=w;    bodyFill = p.color(200, 100, 10);    wingFill = p.color(200, 200, 20);  }  //example getter/setter methods  public void setOffsetX(float offsetX){    this.offsetX = offsetX;  }    public float getOffsetX(float offsetX){    return offsetX;  }    // methods  public void setColor(int bodyFill, int wingFill){    this.bodyFill=bodyFill;    this.wingFill=wingFill;  }  public void setFlight(float radiusX, float radiusY, float radiusZ,                         float rotX, float rotY, float rotZ){    this.radiusX = radiusX;    this.radiusY = radiusY;    this.radiusZ = radiusZ;    this.rotX = rotX;    this.rotY = rotY;    this.rotZ = rotZ;  }  public void setWingSpeed(float flapSpeed){    this.flapSpeed = flapSpeed;  }  public void setRotSpeed(float rotSpeed){    this.rotSpeed = rotSpeed;  }  public void fly(){    p.pushMatrix();    float px, py, pz;    p.fill(bodyFill);    //flight    px = p.sin(p.radians(ang3))*radiusX;    py = p.cos(p.radians(ang3))*radiusY;    pz = p.sin(p.radians(ang4))*radiusZ;    //    p.translate(p.width/2+offsetX+px, p.height/2+offsetY+py,               -500+offsetZ+pz);    p.rotateX(p.sin(p.radians(ang2))*rotX);    p.rotateY(p.sin(p.radians(ang2))*rotY);    p.rotateZ(p.sin(p.radians(ang2))*rotZ);    //body    p.box(w/5, h, w/5);    p.fill(wingFill);    //left wing    p.pushMatrix();    p.rotateY(p.sin(p.radians(ang))*20);    p.rect(0, -h/2, w, h);    p.popMatrix();    //right wing    p.pushMatrix();    p.rotateY(p.sin(p.radians(ang))*-20);    p.rect(-w, -h/2, w, h);    p.popMatrix();    // wing flap    ang+=flapSpeed;    if (ang>3){      flapSpeed*=-1;    }     if (ang<-3){      flapSpeed*=-1;    }    // ang's run trig functions    ang2+=rotSpeed;    ang3+=.7;    ang4+=.55;    p.popMatrix();  }}