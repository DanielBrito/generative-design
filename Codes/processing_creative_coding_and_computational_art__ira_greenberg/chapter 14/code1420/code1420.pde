import processing.core.*;public class Vessel implements IGShape3D{  public float w;  public float h;  public float thickness;  public int detail;  public float cornerRadius;  public int cornerSteps;  // cross section vertices  public Vector3D[]cs;  // all vertices  public Vector3D[]v;  public Triangle3D[]t;  public PApplet p = new PApplet();  // constructor without detail param  public Vessel(float w, float h){    // call main constructor    this(w, h, w/20, 30);  }  // main constructor  public Vessel(float w, float h, float thickness, int detail){    this.w = w;    this.h = h;    this.thickness = thickness;    this.detail = detail;    cornerRadius = thickness*3;    cs = new Vector3D[37];    v = new Vector3D[cs.length*detail];    t = new Triangle3D[((cs.length-1)*2)*detail];    setCrossSection();    setVertices();    setTriangles();  }  //getter/setters  public float getWidth(){    return w;  }  public void setWidth(float w){    this.w = w;  }  public float getHeight(){    return h;  }  public void setHeight(float h){    this.h = h;  }  public  void setCrossSection(){    float px=0, py=0, px2=0, py2=0, ang=90;    float cornerSteps = ((w+h)/2)/10;    float cornerRadius = thickness*3;    int index = 0;    cs[index++] = new Vector3D(0, h/2, 0);    cs[index++] = new Vector3D(-w/2+cornerRadius, h/2, 0);    for (int i=0; i<16; i++){      px = -w/2+cornerRadius+p.cos(PApplet.radians(ang))*-cornerRadius;      py = h/2-cornerRadius+p.sin(PApplet.radians(ang))*cornerRadius;      cs[index++] = new Vector3D(px, py, 0);      ang-=45/16;    }    cs[index++] = new Vector3D(px, -h/2, 0);    ang = 90;    for (int i=0; i<8; i++){      px2 = px+p.cos(PApplet.radians(ang))*thickness;      py2 = -h/2+p.sin(PApplet.radians(ang))*-thickness;      cs[index++] = new Vector3D(px2, py2, 0);      ang-=135/8;    }    py2 = h/2-(cornerRadius+thickness);    cs[index++] = new Vector3D(px2, py2, 0);    ang = 180;    for (int i=0; i<8; i++){      px = px2+cornerRadius+p.cos(PApplet.radians(ang))*cornerRadius;      py = py2+p.sin(PApplet.radians(ang))*cornerRadius;      cs[index++] = new Vector3D(px, py, 0);      ang-=75/8;    }    cs[index++] = new Vector3D(0, py, 0);  }  //required implemented methods   public void setVertices(){    float px = 0, pz = 0;    float ang = 0;    int index = 0;    for (int i=0; i<detail; i++){      for (int j=0; j<cs.length; j++){        pz = p.cos(PApplet.radians(ang))*cs[j].z - p.sin(PApplet.radians(ang))*cs[j].x;        px = p.sin(PApplet.radians(ang))*cs[j].z + p.cos(PApplet.radians(ang))*cs[j].x;        v[index] = new Vector3D(px, cs[j].y, pz);        index++;      }      ang+=360/detail;    }  }  public Vector3D[] getVertices() {    return v;  }  public void setTriangles(){    int index = 0;    int len = cs.length;    for (int i=0; i<detail; i++){      for (int j=0; j<len-1; j++){        if (i<detail-1){          t[index++] = new Triangle3D(v[j+(i*len)], v[j+((i+1)*len)], v[(j+1)+((i+1)*len)]);          t[index++] = new Triangle3D(v[j+(i*len)], v[(j+1)+((i+1)*len)], v[(j+1)+(i*len)]);        }         else {          t[index++] = new Triangle3D(v[j], v[j+(i*len)], v[(j+1)+(i*len)]);          t[index++] = new Triangle3D(v[j],v[(j+1)+(i*len)], v[j+1]);        }      }    }  }  public Triangle3D[] getTriangles(){    return t;  }}