/*  Inheritance Example (complete) linear and radial gradients January 25, 2006 NOTE: This sketch takes some time to render. REQUIRED: Gradient class, LinearGradient class and  RadialGradient class. */void setup(){  size(400, 400);  // fill display window with default black and white   // linear gradient background  LinearGradient lg = new LinearGradient();  lg.create();  //create 4 linear Gradients  color c1 = color(255, 0, 0);  color c2 = color(0, 255, 0);  color c3 = color(255, 255, 0);  color c4 = color(180, 0, 255);  color c5 = color(255, 127, 0);  color c6 = color(0, 0, 255);  color c7 = color(0, 255, 255);  color c8 = color(255, 180, 0);  Rectangle r1 = new Rectangle(50, 50, 150, 150);  Rectangle r2 = new Rectangle(200, 50, 150, 150);  Rectangle r3 = new Rectangle(50, 200, 150, 150);  Rectangle r4 = new Rectangle(200, 200, 150, 150);  LinearGradient lg1 = new LinearGradient(c1, c2, r1, Gradient.AXIS_HORIZONTAL);  lg1.create();  LinearGradient lg2 = new LinearGradient(c3, c4, r2);  lg2.create();  LinearGradient lg3 = new LinearGradient(c5, c6, r3);  lg3.create();  LinearGradient lg4 = new LinearGradient(c7, c8, r4, Gradient.AXIS_HORIZONTAL);  lg4.create();  //create 4 radial Gradients   c1 = color(0, 150, 200);  c2 = color(200, 200, 100);  c3 = color(190, 225, 290);  c4 = color(90, 45, 20);  c5 = color(195, 195, 90);  c6 = color(30, 10, 70);  c7 = color(0);  c8 = color(255);  r1 = new Rectangle(60, 60, 130, 130);  r2 = new Rectangle(225, 60, 100, 130);  r3 = new Rectangle(60, 225, 130, 100);  r4 = new Rectangle(210, 210, 130, 130);  RadialGradient rg1 = new RadialGradient(c1, c2, r1);  rg1.create();  RadialGradient rg2 = new RadialGradient(c3, c4, r2);  rg2.create();  RadialGradient rg3 = new RadialGradient(c5, c6, r3);  rg3.create();  RadialGradient rg4 = new RadialGradient(c7, c8, r4);  rg4.create();}abstract class Gradient {  // constants  // these can't be changed  final static int AXIS_VERTICAL = 0;  final static int AXIS_HORIZONTAL = 1;  // instance fields with default values  // these can be changed  color c1 = color(255);  color c2 = color(0);  Rectangle bounds  = new Rectangle(0, 0, width, height);  // abstarct method, to be implmented by subclasses  abstract void create();/* concrete methods*///getter/setters  void setColor1(color c1){    this.c1 = c1;  }  color getColor1(){    return c1;  }  void setColor2(color c2){    this.c2 = c2;  }  color getColor2(){    return c2;  }  void setBounds(Rectangle Bounds){    this.bounds = bounds;  }  Rectangle getBounds(){    return bounds;  }}class LinearGradient extends Gradient {  int axis;  //default constructor  LinearGradient() {    axis = AXIS_VERTICAL;  }  //constructor  LinearGradient(color c1, color c2) {    this.c1 = c1;    this.c2 = c2;    axis = AXIS_VERTICAL;  }    //constructor  LinearGradient(color c1, color c2, Rectangle bounds) {    this.c1 = c1;    this.c2 = c2;    this.bounds = bounds;    axis = AXIS_VERTICAL;  }    //constructor  LinearGradient(color c1, color c2, Rectangle bounds, int axis) {    this.c1 = c1;    this.c2 = c2;    this.bounds = bounds;    this.axis = axis;  }  // required: implemented create method  void create(){    // calculate differences between color components     float deltaR = red(c2)-red(c1);    float deltaG = green(c2)-green(c1);    float deltaB = blue(c2)-blue(c1);    // y axis    if(axis == AXIS_VERTICAL){      for (int i=bounds.x; i<=(bounds.x+bounds.width); i++){        for (int j = bounds.y; j<=(bounds.y+bounds.height); j++){          color c = color(          (red(c1)+(j-bounds.y)*(deltaR/bounds.height)),          (green(c1)+(j-bounds.y)*(deltaG/bounds.height)),          (blue(c1)+(j-bounds.y)*(deltaB/bounds.height)) );          set(i, j, c);        }      }      }      // x axis    else {      for (int i=bounds.y; i<=(bounds.y+bounds.height); i++){        for (int j = bounds.x; j<=(bounds.x+bounds.width); j++){          color c = color(          // I think bounds.height should be width          (red(c1)+(j-bounds.x)*(deltaR/bounds.width)),          (green(c1)+(j-bounds.x)*(deltaG/bounds.width)),          (blue(c1)+(j-bounds.x)*(deltaB/bounds.width)) );          set(j, i, c);        }      }      }  }    void setAxis(int axis){    this.axis = axis;  }  int getAxis(){    return axis;  }}class RadialGradient extends Gradient {  //default constructor  RadialGradient() {    super();  }  //constructor  RadialGradient(color c1, color c2) {    this.c1 = c1;    this.c2 = c2;  }  //constructor  RadialGradient(color c1, color c2, Rectangle bounds) {    this.c1 = c1;    this.c2 = c2;   this.bounds = bounds;  }  // required: implemented create method  void create(){    float px = 0, py = 0, angle = 0;    float radius1 = bounds.width/2;    float radius2 = bounds.height/2;    float centerX = bounds.x+radius1;    float centerY = bounds.y+radius2;    float radiusMax = max(radius1, radius2);    // calculate differences between color components     float deltaR = red(c2)-red(c1);    float deltaG = green(c2)-green(c1);    float deltaB = blue(c2)-blue(c1);    // gapFiller ensures there are no holes in gradient    float gapFiller = 8.0;    for (int i=0; i<radiusMax; i++){      for (float j=0; j<360; j+=1.0/gapFiller){        if (radius1>radius2){          px = centerX+cos(radians(angle))*i;          py = centerY+sin(radians(angle))*(i-(radius1-radius2));        }         else {          px = centerX+cos(radians(angle))*(i-(radius2-radius1));          py = centerY+sin(radians(angle))*i;        }        angle+=1.0/gapFiller;        color c = color(        (red(c1)+(i)*(deltaR/radiusMax)),        (green(c1)+(i)*(deltaG/radiusMax)),        (blue(c1)+(i)*(deltaB/radiusMax))           );        set(int(px), int(py), c);            }    }  }}